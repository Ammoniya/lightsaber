<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.js"></script>
  <script src="https://docs.opencv.org/3.4.1/opencv.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
    var videoElement ;
    var canvasElement;
    var canvasCtx;
    let img;
    var initialized=false;
    //let handDetected=false;
    var prevRatio=0;
    let rotatedRect;
    let joints;
    //let circle1;
    //let circle2;
       
    let angle;
    function setup() {}
    function draw() {
      //if(initialized){
       clear();
       background(255,255,255,0);
       //if(rotatedRect){  
      if(joints){
        var p1=joints[4];
        var p2=joints[7];
        var p3=joints[19];
        p1.x=p1.x*1280;
        p2.x=p2.x*1280;
        p3.x=p3.x*1280;
        p1.y=p1.y*720;
        p2.y=p2.y*720;
        p3.y=p3.y*720;
          var distance1 = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
          var distance2 = Math.sqrt(Math.pow(p2.x - p3.x, 2) + Math.pow(p2.y - p3.y, 2));
         // console.log(distance1+","+distance2+","+distance1/distance2);
        
         var ratio=distance1/distance2;//1-circle2.radius/circle1.radius;
         //1.3:sumb up 0.6:close
         ratio=map(ratio,0.95,1.3,0,1,true);
         ratio =ratio*(rotatedRect.size.width*2.0/76.0);
         ratio=0.3*ratio+0.7*prevRatio;
         prevRatio=ratio;
                 
         //角度の計算は要改良
         angle = rotatedRect.angle;
         if(angle<90){
           angle=angle-180;
         }
         
         push();
         translate(rotatedRect.center.x, rotatedRect.center.y);
       // translate(mouseX, mouseY);
         rotate(angle*PI /180.0);
         scale(ratio, ratio);
         translate(-img.width/2.0,0);
         image(img,0,0);
         pop();
       }
      //}
    }
    
    window.onload = function() {
      videoElement = document.getElementsByClassName('input_video')[0];
      canvasElement = document.getElementsByClassName('output_canvas')[0];
      canvasCtx = canvasElement.getContext('2d');
      img = loadImage('./saber.png');
      const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
      }});
      
      hands.setOptions({
        maxNumHands: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
        useCpuInference: false, //if m1 mac: true, else: false
        selfieMode:true
      });
      hands.onResults(onResults);
      const camera = new Camera(videoElement, {
        onFrame: async () => {
          await hands.send({image: videoElement});
        },
        width: 1280,
        height: 720
      });
      camera.start();
    };
    
    function cvFunction(landmarks,width,height){      
      let points1 = [];
      //let points2 = [];
      for(var i=2;i<21;i++){
        points1.push(landmarks[i].x*width);
        points1.push(landmarks[i].y*height);
        //親指意外を格納
        //if(i>4){
        //  points2.push(landmarks[i].x*width);
        //  points2.push(landmarks[i].y*height);            
        //}
      }
           
      let mat = cv.matFromArray(points1.length/2, 1, cv.CV_32SC2, points1);
      //let mat2 = cv.matFromArray(points2.length/2, 1, cv.CV_32SC2, points2);
      
      rotatedRect = cv.fitEllipse(mat);
      //circle1=cv.minEnclosingCircle(mat);
      //circle2=cv.minEnclosingCircle(mat2);
      
      mat.delete();
      //mat2.delete();          
    }
   
    function onResults(results) {  
      if(!initialized){
        initialized=true;
        var w=max(results.image.width, results.image.height);
        var h=min(results.image.width, results.image.height);
        createCanvas(w, h);
      }
      //handDetected=false;
      joints=null;
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);      
      if (results.multiHandLandmarks) {  
        for (const landmarks of results.multiHandLandmarks) {    
          //handDetected=true;
          joints=landmarks;
          drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS,{color: '#00FF00', lineWidth: 2});
          drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1,radius:2});  
          cvFunction(landmarks,results.image.width,results.image.height);         
        }
      }
      canvasCtx.restore();  
    }
  </script>
</head>

<body>
  <div class="container">
    <video class="input_video" style="position:absolute; display:none;"></video>
    <canvas class="output_canvas" width="1280px" height="720px" style="position:absolute;"></canvas>
    <main style="position:absolute;">
    </main>
  </div>
</body>
</html>